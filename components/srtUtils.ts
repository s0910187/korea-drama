export const downloadFile = (content: string, fileName: string, mimeType: string) => {
    // Add BOM for UTF-8 to ensure Excel and other editors open it correctly
    const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
    const blob = new Blob([bom, content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};

// Regex for single-line notes. It specifically excludes newlines inside the brackets.
const SINGLE_LINE_NOTE_REGEX = /^(?:\([^()\r\n]*\)|（[^（）\r\n]*）|\[[^[\]\r\n]*\]|〔[^〔〕\r\n]*〕)$/;

// Regex for multi-line notes. It allows any character, including newlines, between the outer brackets.
const MULTI_LINE_NOTE_REGEX = /^(?:\[[\s\S]*\]|\([\s\S]*\)|\（[\s\S]*\）|〔[\s\S]*〕)$/;

const srtTimeToAss = (srtTime: string): string => {
    const parts = srtTime.split(/[:,]/);
    if (parts.length !== 4) return "0:00:00.00";
    const h = parseInt(parts[0], 10);
    const m = parseInt(parts[1], 10);
    const s = parseInt(parts[2], 10);
    const ms = parseInt(parts[3], 10);
    // Convert milliseconds to centiseconds
    const cs = Math.round(ms / 10);
    return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${cs.toString().padStart(2, '0')}`;
};

const convertSrtTagsToAss = (text: string): string => {
    let newText = text;
    // Italic
    newText = newText.replace(/<i>/g, '{\\i1}').replace(/<\/i>/g, '{\\i0}');
    // Bold
    newText = newText.replace(/<b>/g, '{\\b1}').replace(/<\/b>/g, '{\\b0}');
    // Underline
    newText = newText.replace(/<u>/g, '{\\u1}').replace(/<\/u>/g, '{\\u0}');
    // Font color
    newText = newText.replace(/<font color="?#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})"?/gi, '{\\c&H$3$2$1&}');
    newText = newText.replace(/<\/font>/g, '{\\c}');

    return newText;
};


export const convertSrtToAss = (srtContent: string): string => {
    const header = `[Script Info]
; Script generated by 韓劇韓綜字幕翻譯機
Title: Converted Subtitle
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,22,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.5,0.5,2,10,10,10,1
Style: Notes,Arial,22,&H0013E9F7,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.5,0.5,2,10,10,50,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

    const blocks = srtContent.trim().replace(/\r\n/g, '\n').split(/\n\s*\n/);
    let assEvents = '';

    for (const block of blocks) {
        const lines = block.split('\n');
        if (lines.length < 2) continue;

        const timestampLine = lines.find(line => line.includes('-->'));
        if (!timestampLine) continue;
        
        const timeMatch = timestampLine.match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
        if (!timeMatch) continue;

        const startTime = srtTimeToAss(timeMatch[1]);
        const endTime = srtTimeToAss(timeMatch[2]);
        const textLines = lines.filter(line => !line.includes('-->') && !/^\d+$/.test(line.trim()));
        
        if (textLines.length === 0) continue;

        const fullTextContent = textLines.join('\n').trim();

        // ** BUG FIX **
        // First, check if the ENTIRE block is a multi-line note.
        if (MULTI_LINE_NOTE_REGEX.test(fullTextContent)) {
            const noteText = convertSrtTagsToAss(textLines.join('\\N').trim());
            if (noteText) {
                assEvents += `Dialogue: 0,${startTime},${endTime},Notes,,0,0,0,,${noteText}\n`;
            }
        } else {
            // If not a full block note, process line-by-line for mixed content.
            const notes = textLines.filter(line => SINGLE_LINE_NOTE_REGEX.test(line.trim()));
            const dialogues = textLines.filter(line => !SINGLE_LINE_NOTE_REGEX.test(line.trim()));
            
            if (dialogues.length > 0) {
                const dialogueText = convertSrtTagsToAss(dialogues.join('\\N').trim());
                if (dialogueText) {
                    assEvents += `Dialogue: 0,${startTime},${endTime},Default,,0,0,0,,${dialogueText}\n`;
                }
            }
            
            for (const note of notes) {
                const noteText = convertSrtTagsToAss(note.trim());
                if (noteText) {
                    assEvents += `Dialogue: 0,${startTime},${endTime},Notes,,0,0,0,,${noteText}\n`;
                }
            }
        }
    }
    
    return header + assEvents;
};